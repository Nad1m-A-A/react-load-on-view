import r,{useState as e,useEffect as t,useRef as n}from"react";function i(r,n){const[i,a]=e({}),[o,s]=e(""),[c,l]=e(!1),[u,g]=e(!1),d=n&&Array.isArray(r)&&r.length>0&&!u;return t((()=>{if(!d)return;let e=!0;return(async()=>{let t;l(!0),s("");try{t=await async function(r){return Promise.all(r.map((async r=>{if(function(r){return/\.(jpg|jpeg|png|gif|webp|svg)$/i.test(r)}(r))return{src:r};try{const e=await import(r);return e.default||e}catch(r){throw r}})))}(r)}catch(r){e&&function(r,e,t){r(t.message||"Failed to load data"),e({})}(s,a,r)}finally{e&&l(!1)}e&&t&&(!function(r,e){r.every((r=>r?.src))?e({images:r}):e(function(r){return r.reduce(((r,e)=>(e?.src?(r.images=r.images||[],r.images.push(e)):r={...r,...e},r)),{})}(r))}(t,a),g(!0))})(),()=>{e=!1}}),[r,n,u]),{data:i,error:o,loading:c}}function a({rootMargin:r="0px",threshold:i=0,triggerOnce:a=!0,root:o=null}={}){const[s,c]=e(!1),[l,u]=e(null),g=n(null);return t((()=>{let e=!0;const t=new IntersectionObserver((([r])=>{e&&(u(r),c(r.isIntersecting),r.isIntersecting&&a&&t.disconnect())}),{root:o,rootMargin:r,threshold:i}),n=g.current;return n&&t.observe(n),()=>{e=!1,n&&t.unobserve(n),t.disconnect()}}),[r,i,a,o]),{ref:g,inView:s}}function o(e,{animate:t=!1,afterWrapperIsVisibleClass:n="visible_wrapper",initialWrapperClass:o=(t?"invisible_wrapper":""),rootMargin:s="0px",threshold:c=0,root:l=null,triggerOnce:u=!0,lazyLoad:g=!1,paths:d=[]}={}){return function(p){const{ref:f,inView:m}=a({rootMargin:s,threshold:c,root:l,triggerOnce:u}),{data:h,error:y,loading:w}=g?i(d,m):{data:{},error:"",loading:!1},v=g?{...p,data:h,error:y,loading:w}:p,b=t&&m?p.special_animation||n:o;return r.createElement("div",{ref:f,className:b},r.createElement(e,v))}}export{a as useElementObserver,i as useLazyLoadAssets,o as withViewObserver};
